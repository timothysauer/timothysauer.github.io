<!DOCTYPE html>
<html>
<head>
<title>Numerical Analysis 4th Edition Sauer </title>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
</head>

<h3>COMPUTER PROBLEMS 6.3</h3>
\(\def\ds{\displaystyle} \)
<b>1 (a)</b> The code <tt>euler2.py</tt> in Program 6.2  can be used to calculate the
two approximations, for step sizes \(h=0.1\) and \(h=0.01\). For \(h=0.1\), the global
truncation errors are \([0.1973, 0.1592]\) for \(w_{n1}\) and \(w_{n2}\), \(n=10\).
 For \(h=0.01\), the global
truncation errors are \([0.0226, 0.0149]\) for \(w_{n1}\) and \(w_{n2}\), \(n=100\). The errors
decrease by roughly a factor of 10 for the smaller step size, as expected for a first
order method. The plots of the two approximations and the correct solution (dashed)
are below. <p>
<img width=300 async src="figs/cp6o3o1a.png" align=left>
<br clear="all" />
<p>
<b>1 (b)</b> Similar to (a). The global truncation errors are \([0.0328, 0.0219]\) for
step size \(h=0.1\), and \([0.0031, 0.0020]\) for \(h=0.01\). <p>
<img width=300 async src="figs/cp6o3o1b.png" align=left>
<br clear="all" />
<p>
<b>1 (c)</b> Similar to (a). The global truncation errors are \([0.0305, 0.0410]\) for
step size \(h=0.1\), and \([0.0027, 0.0042]\) for \(h=0.01\). <p>
<img width=300 async src="figs/cp6o3o1c.png" align=left>
<br clear="all" />
<p>
<b>1 (d)</b> Similar to (a). The global truncation errors are \([51.4030, 51.3070]\) for
step size \(h=0.1\), and \([8.1919, 8.1827]\) for \(h=0.01\). <p>
<img width=300 async src="figs/cp6o3o1d.png" align=left>
<br clear="all" />
<p>
<hr>

<b>3</b> To modify <tt>pend</tt> to exhibit damping, add the term \(-dy_2\) to the \(y_2'\)
equation in the <tt>ydot</tt> function, where \(d=0.1\). All initial conditions lead toward
the straight-down position of the pendulum, except for the straight-up position
\(y_1(0)=\pi, y_2(0)=0\). In theory, this position is an unstable steady-state, meaning
that it will never move unless there is a small outside perturbation.
For a physical pendulum, small perturbations will occur, and the pendulum will fall from
the up position. The outcome of the simulation with <tt>pend</tt> depends on the step size
and the fact that \(\sin \pi\) is not exactly zero. It differs
on the order of machine epsilon, providing the perturbation needed, at least when
step size \(h=0.05\) is used,
to cause the pendulum to fall and eventually move to the straight-down position as a
physical pendulum would.
<hr>

<b>5</b> To modify <tt>pend</tt> to exhibit periodic forcing and damping,
add the term \(-dy_2+A\sin t\) to the \(y_2'\)
equation in the <tt>ydot</tt> function, where \(d=1\) and \(A=12\). After waiting for
transient effects to die down, the pendulum will settle into one of
two stable trajectories. One of them makes three and one-half clockwise revolutions
followed by two and one-half counterclockwise revolutions, and repeats. The other
does the same, replacing clockwise with counterclockwise. For example, the initial
condition \((y_1, y_2)=(0.2, 0)\) settles into the first motion, and the initial
condition \((y_1, y_2)=(0.15, 0)\) converges to the second.
<hr>

<b>7</b> The <tt>ydot</tt> function in <tt>pend.py</tt> must be modified to solve the system
\begin{eqnarray*}
y_1'&=&y_2\\
y_2'&=& \left(-\frac{g}{l}+A\cos 2\pi t \right)\sin y_1-dy_2
\end{eqnarray*}
where \(g=9.81, l=2.5\). Starting with an initial position that is close to, but not
exactly, zero (for example, \((y_1,y_2)=(0.01,0)\)), one finds that for \(A\) above \(13.2\),
the downward position is unstable as defined in the Computer Problem, in that the pendulum
travels through the upward position.
<hr>

<b>9</b> To adjust <tt>orbit.py</tt> to solve the two-body problem, 
the stationary sun must be changed into a moving body. Some example code:
<pre>
import numpy as np
import matplotlib.pyplot as plt

def orbit(inter, ic, n, p):
    """
    Input:  inter time interval
            ic initial conditions [x0,vx0,y0,vy0]
            n number of steps
            p step per plotted point
    Output: t time points
            traj orbital trajectory
    """
    h = (inter[1] - inter[0]) / n  # Step size
    x00, vx00, y00, vy00,x10,vx10,y10,vy10 = ic  # Initial conditions
    traj = np.zeros((n+1, 8))  # Initialize position and velocity array
    y = np.zeros((p+1, 8))
    y[0, :] = [x00, vx00, y00, vy00,x10, vx10, y10, vy10]
    t = np.zeros((n+1))  # Time array
    t[0] = inter[0]
    plt.figure()
    plt.xlim(-5, 5)
    plt.ylim(-5, 5)
    #plt.plot(0, 0, 'yo', markersize=16) # Draw sun at origin
    # Prepare line objects for head and tail of the orbit
    head1, = plt.plot([], [], 'ro', markersize=8)
    tail1, = plt.plot([], [], 'b-', linestyle='-', markersize=4)
    head2, = plt.plot([], [], 'yo', markersize=8)
    tail2, = plt.plot([], [], 'b-', linestyle='-', markersize=4)
    plt.ion()  # Enable interactive mode for real-time plotting
    for k in range(n // p):
        for i in range(p):
            t[k*p+i+1] = t[k*p+i] + h
            y[i + 1, :] = trapstep(ydot, t[i], y[i, :], h)
        traj[k*p+1:(k+1)*p+1,:] = y[1:,:]
        # Update the position for the next frame
        set_position(head1, y[p, 0], y[p, 2])  # Update head position
        set_position(tail1, traj[1:(k+1)*p+1, 0], traj[1:(k+1)*p+1, 2]) 
        set_position(head2, y[p, 4], y[p, 6])  # Update head position
        set_position(tail2, traj[1:(k+1)*p+1, 4], traj[1:(k+1)*p+1, 6]) 
        y[0, :] = y[p, :]  # Update last computed position
        plt.draw()
        plt.pause(0.01)  # Pause to visualize updates
    plt.ioff()  # Disable interactive mode
    plt.show()  # Show the plot window
    return t, traj

def eulerstep(ydot, t, x, h): return x + h*ydot(t, x)

def trapstep(ydot, t, y, h): return y + h/2.*(ydot(t, y)+ydot(t+h,y+h*ydot(t,y)))


def ydot(t, x):
    m0 = 0.03
    m1 = 0.3  # Mass of the second object
    g = 1   # Gravitational acceleration
    mg0,mg1 = m0*g,m1*g
    px0,vx0,py0,vy0,px1,vx1,py1,vy1 = x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7]  # Unpack values
    dist = np.sqrt((px1 - px0)**2 + (py1 - py0)**2)
    z = np.zeros(8)
    z[0] = vx0
    z[1] = (mg1*(px1 - px0))/(dist**3)  # Acceleration in x
    z[2] = vy0
    z[3] = (mg1*(py1 - py0))/(dist**3)  # Acceleration in y
    z[4] = vx1
    z[5] = (mg0*(px0 - px1))/(dist**3)  # Acceleration in x
    z[6] = vy1
    z[7] = (mg0*(py0 - py1))/(dist**3)  # Acceleration in y
    return z


def set_position(line, xdata, ydata):
    line.set_data(xdata, ydata)  # Function to set the position of plot points

# Example usage
orbit([0, 100], [2,0.2,2,-0.2,0,-0.02,0,0.02], 10000, 5)
</pre>
<hr>

<b>11</b> Using the code from Computer Problem 9, one can run <p>
    <pre>
    orbit([0, 100], [0,0.2,1,-0.2,-2,-0.2,-1,0.2], 10000, 5) 
    </pre> <p>
along with the given masses. The orbits have some near passes, at which extra precision 
is needed to preserve accuracy. 
<hr>
<b>13</b> 


</html>